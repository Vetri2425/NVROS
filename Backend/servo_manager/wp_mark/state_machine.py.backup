"""
WP_MARK State Machine Module
Provides robust state management with validation, transitions, and consistency checks
"""

import time
import threading
from enum import Enum
from typing import Dict, Any, Optional, Callable, List
from dataclasses import dataclass
import logging


class MissionPhase(Enum):
    """Mission execution phases with enhanced state tracking"""
    IDLE = "idle"
    INITIALIZING = "initializing"
    NAVIGATING = "navigating"
    WAITING_ARRIVAL = "waiting_arrival"
    DELAY_BEFORE_START = "delay_before_start"
    SPRAYING = "spraying"
    DELAY_AFTER_STOP = "delay_after_stop"
    COMPLETED = "completed"
    ERROR = "error"
    RECOVERING = "recovering"


class StateTransitionError(Exception):
    """Raised when an invalid state transition is attempted"""
    pass


class StateValidationError(Exception):
    """Raised when state consistency validation fails"""
    pass


@dataclass
class StateContext:
    """Context information for state transitions"""
    phase: MissionPhase
    waypoint_index: int
    total_waypoints: int
    mission_active: bool
    last_action: str
    timestamp: float
    gps_valid: bool
    services_available: bool
    error_count: int
    retry_count: int


class StateValidator:
    """Validates state consistency and transitions"""

    @staticmethod
    def validate_transition(from_phase: MissionPhase, to_phase: MissionPhase,
                          context: StateContext) -> bool:
        """
        Validate if a state transition is allowed

        Args:
            from_phase: Current phase
            to_phase: Target phase
            context: Current state context

        Returns:
            True if transition is valid
        """
        # Define valid transitions
        valid_transitions = {
            MissionPhase.IDLE: [MissionPhase.INITIALIZING],
            MissionPhase.INITIALIZING: [MissionPhase.NAVIGATING, MissionPhase.ERROR],
            MissionPhase.NAVIGATING: [MissionPhase.WAITING_ARRIVAL, MissionPhase.ERROR],
            MissionPhase.WAITING_ARRIVAL: [MissionPhase.DELAY_BEFORE_START, MissionPhase.NAVIGATING, MissionPhase.ERROR],
            MissionPhase.DELAY_BEFORE_START: [MissionPhase.SPRAYING, MissionPhase.ERROR],
            MissionPhase.SPRAYING: [MissionPhase.DELAY_AFTER_STOP, MissionPhase.ERROR],
            MissionPhase.DELAY_AFTER_STOP: [MissionPhase.NAVIGATING, MissionPhase.COMPLETED, MissionPhase.ERROR],
            MissionPhase.ERROR: [MissionPhase.RECOVERING, MissionPhase.IDLE],
            MissionPhase.RECOVERING: [MissionPhase.IDLE, MissionPhase.ERROR],
            MissionPhase.COMPLETED: [MissionPhase.IDLE]
        }

        if to_phase not in valid_transitions.get(from_phase, []):
            return False

        # Additional context validation
        if to_phase == MissionPhase.NAVIGATING:
            if not context.gps_valid:
                return False
            if context.waypoint_index >= context.total_waypoints:
                return False

        if to_phase == MissionPhase.SPRAYING:
            if not context.services_available:
                return False

        return True

    @staticmethod
    def validate_state_consistency(context: StateContext) -> List[str]:
        """
        Validate overall state consistency

        Args:
            context: Current state context

        Returns:
            List of validation error messages (empty if valid)
        """
        errors = []

        # Mission active consistency
        if context.phase == MissionPhase.IDLE and context.mission_active:
            errors.append("Mission marked active but phase is IDLE")

        if context.phase in [MissionPhase.NAVIGATING, MissionPhase.WAITING_ARRIVAL,
                           MissionPhase.SPRAYING] and not context.mission_active:
            errors.append("Mission phase indicates active execution but mission_active is False")

        # Waypoint index bounds
        if context.waypoint_index < 0:
            errors.append("Waypoint index cannot be negative")

        if context.total_waypoints > 0 and context.waypoint_index >= context.total_waypoints:
            if context.phase not in [MissionPhase.COMPLETED, MissionPhase.ERROR]:
                errors.append("Waypoint index exceeds total waypoints")

        # GPS requirement for navigation phases
        nav_phases = [MissionPhase.NAVIGATING, MissionPhase.WAITING_ARRIVAL]
        if context.phase in nav_phases and not context.gps_valid:
            errors.append("GPS required for navigation phases")

        # Error count limits
        if context.error_count > 10:
            errors.append("Excessive error count detected")

        return errors


class CircuitBreaker:
    """Circuit breaker pattern for handling transient failures"""

    def __init__(self, failure_threshold: int = 3, recovery_timeout: float = 60.0,
                 expected_exception: Exception = Exception):
        """
        Initialize circuit breaker

        Args:
            failure_threshold: Number of failures before opening circuit
            recovery_timeout: Time to wait before attempting recovery
            expected_exception: Exception type to catch
        """
        self.failure_threshold = failure_threshold
        self.recovery_timeout = recovery_timeout
        self.expected_exception = expected_exception

        self.failure_count = 0
        self.last_failure_time = None
        self.state = "CLOSED"  # CLOSED, OPEN, HALF_OPEN

        self._lock = threading.Lock()

    def call(self, func: Callable, *args, **kwargs):
        """
        Execute function with circuit breaker protection

        Args:
            func: Function to execute
            *args: Positional arguments
            **kwargs: Keyword arguments

        Returns:
            Function result

        Raises:
            Exception: If circuit is open or function fails
        """
        with self._lock:
            if self.state == "OPEN":
                if time.time() - self.last_failure_time > self.recovery_timeout:
                    self.state = "HALF_OPEN"
                else:
                    raise Exception("Circuit breaker is OPEN")

            try:
                result = func(*args, **kwargs)
                self._on_success()
                return result
            except self.expected_exception as e:
                self._on_failure()
                raise e

    def _on_success(self):
        """Handle successful execution"""
        if self.state == "HALF_OPEN":
            self.state = "CLOSED"
            self.failure_count = 0

    def _on_failure(self):
        """Handle failed execution"""
        self.failure_count += 1
        self.last_failure_time = time.time()

        if self.failure_count >= self.failure_threshold:
            self.state = "OPEN"

    def get_state(self) -> str:
        """Get current circuit breaker state"""
        with self._lock:
            return self.state


class StateMachine:
    """Robust state machine for WP_MARK mission management"""

    def __init__(self, logger: Optional[logging.Logger] = None):
        """
        Initialize state machine

        Args:
            logger: Optional logger instance
        """
        self.logger = logger or logging.getLogger('StateMachine')

        # Current state
        self.current_phase = MissionPhase.IDLE
        self.context = StateContext(
            phase=MissionPhase.IDLE,
            waypoint_index=0,
            total_waypoints=0,
            mission_active=False,
            last_action="Initialized",
            timestamp=time.time(),
            gps_valid=False,
            services_available=False,
            error_count=0,
            retry_count=0
        )

        # State management
        self._lock = threading.RLock()
        self._transition_history: List[Dict[str, Any]] = []
        self._validators = [StateValidator.validate_state_consistency]
        self._transition_listeners: List[Callable] = []

        # Circuit breakers for different operations
        self._servo_circuit_breaker = CircuitBreaker(
            failure_threshold=3,
            recovery_timeout=30.0
        )
        self._waypoint_circuit_breaker = CircuitBreaker(
            failure_threshold=2,
            recovery_timeout=15.0
        )

        # Health monitoring
        self._last_health_check = time.time()
        self._health_check_interval = 5.0  # seconds

        self.logger.info("State machine initialized")

    def transition_to(self, new_phase: MissionPhase, action: str = "",
                     force: bool = False) -> bool:
        """
        Transition to a new phase with validation

        Args:
            new_phase: Target phase
            action: Description of the action causing transition
            force: Force transition even if invalid

        Returns:
            True if transition successful
        """
        with self._lock:
            old_phase = self.current_phase

            # Validate transition
            if not force and not StateValidator.validate_transition(old_phase, new_phase, self.context):
                error_msg = f"Invalid transition: {old_phase.value} -> {new_phase.value}"
                self.logger.error(error_msg)
                self._record_transition_error(old_phase, new_phase, error_msg)
                raise StateTransitionError(error_msg)

            # Update state
            self.current_phase = new_phase
            self.context.phase = new_phase
            self.context.timestamp = time.time()

            if action:
                self.context.last_action = action

            # Validate consistency
            validation_errors = self._validate_current_state()
            if validation_errors and not force:
                error_msg = f"State validation failed: {validation_errors}"
                self.logger.error(error_msg)
                # Rollback transition
                self.current_phase = old_phase
                self.context.phase = old_phase
                raise StateValidationError(error_msg)

            # Record successful transition
            self._record_transition(old_phase, new_phase, action)

            # Notify listeners
            self._notify_transition_listeners(old_phase, new_phase, action)

            self.logger.info(f"State transition: {old_phase.value} -> {new_phase.value}")
            return True

    def update_context(self, **kwargs):
        """
        Update state context with validation

        Args:
            **kwargs: Context fields to update
        """
        with self._lock:
            for key, value in kwargs.items():
                if hasattr(self.context, key):
                    setattr(self.context, key, value)
                else:
                    self.logger.warning(f"Unknown context field: {key}")

            # Validate updated state
            validation_errors = self._validate_current_state()
            if validation_errors:
                self.logger.warning(f"Context update caused validation errors: {validation_errors}")

    def get_status(self) -> Dict[str, Any]:
        """
        Get current status with health information

        Returns:
            Status dictionary
        """
        with self._lock:
            # Perform health check if needed
            if time.time() - self._last_health_check > self._health_check_interval:
                self._perform_health_check()

            return {
                'phase': self.current_phase.value,
                'context': {
                    'waypoint_index': self.context.waypoint_index,
                    'total_waypoints': self.context.total_waypoints,
                    'mission_active': self.context.mission_active,
                    'last_action': self.context.last_action,
                    'gps_valid': self.context.gps_valid,
                    'services_available': self.context.services_available,
                    'error_count': self.context.error_count,
                    'retry_count': self.context.retry_count
                },
                'health': {
                    'circuit_breakers': {
                        'servo': self._servo_circuit_breaker.get_state(),
                        'waypoint': self._waypoint_circuit_breaker.get_state()
                    },
                    'validation_errors': self._validate_current_state(),
                    'last_health_check': self._last_health_check
                },
                'timestamp': self.context.timestamp
            }

    def add_transition_listener(self, listener: Callable):
        """
        Add listener for state transitions

        Args:
            listener: Function to call on transitions (old_phase, new_phase, action)
        """
        with self._lock:
            self._transition_listeners.append(listener)

    def execute_with_circuit_breaker(self, operation: str, func: Callable, *args, **kwargs):
        """
        Execute function with appropriate circuit breaker

        Args:
            operation: Type of operation ('servo' or 'waypoint')
            func: Function to execute
            *args: Positional arguments
            **kwargs: Keyword arguments

        Returns:
            Function result

        Raises:
            Exception: If circuit breaker is open or function fails
        """
        breaker = {
            'servo': self._servo_circuit_breaker,
            'waypoint': self._waypoint_circuit_breaker
        }.get(operation, self._servo_circuit_breaker)

        return breaker.call(func, *args, **kwargs)

    def increment_error_count(self):
        """Increment error count and check for error state"""
        with self._lock:
            self.context.error_count += 1

            # Auto-transition to error state if too many errors
            if self.context.error_count > 5 and self.current_phase != MissionPhase.ERROR:
                try:
                    self.transition_to(MissionPhase.ERROR, "Too many errors detected")
                except (StateTransitionError, StateValidationError):
                    self.logger.error("Failed to transition to error state")

    def increment_retry_count(self):
        """Increment retry count"""
        with self._lock:
            self.context.retry_count += 1

    def reset_error_state(self):
        """Reset error counters"""
        with self._lock:
            self.context.error_count = 0
            self.context.retry_count = 0

    def _validate_current_state(self) -> List[str]:
        """Validate current state consistency"""
        errors = []
        for validator in self._validators:
            try:
                errors.extend(validator(self.context))
            except Exception as e:
                errors.append(f"Validator error: {str(e)}")
        return errors

    def _record_transition(self, from_phase: MissionPhase, to_phase: MissionPhase, action: str):
        """Record successful state transition"""
        transition = {
            'timestamp': time.time(),
            'from_phase': from_phase.value,
            'to_phase': to_phase.value,
            'action': action,
            'context': {
                'waypoint_index': self.context.waypoint_index,
                'error_count': self.context.error_count
            }
        }

        self._transition_history.append(transition)

        # Keep only last 100 transitions
        if len(self._transition_history) > 100:
            self._transition_history = self._transition_history[-100:]

    def _record_transition_error(self, from_phase: MissionPhase, to_phase: MissionPhase, error: str):
        """Record failed transition attempt"""
        transition_error = {
            'timestamp': time.time(),
            'attempted_from': from_phase.value,
            'attempted_to': to_phase.value,
            'error': error
        }

        # Could be stored in a separate error log
        self.logger.error(f"Transition error: {transition_error}")

    def _notify_transition_listeners(self, old_phase: MissionPhase, new_phase: MissionPhase, action: str):
        """Notify all transition listeners"""
        for listener in self._transition_listeners:
            try:
                listener(old_phase, new_phase, action)
            except Exception as e:
                self.logger.error(f"Transition listener error: {str(e)}")

    def _perform_health_check(self):
        """Perform periodic health checks"""
        self._last_health_check = time.time()

        # Check circuit breaker states
        servo_state = self._servo_circuit_breaker.get_state()
        waypoint_state = self._waypoint_circuit_breaker.get_state()

        if servo_state == "OPEN":
            self.logger.warning("Servo circuit breaker is OPEN")
        if waypoint_state == "OPEN":
            self.logger.warning("Waypoint circuit breaker is OPEN")

        # Validate current state
        validation_errors = self._validate_current_state()
        if validation_errors:
            self.logger.warning(f"State validation errors: {validation_errors}")

    def get_transition_history(self, limit: int = 10) -> List[Dict[str, Any]]:
        """
        Get recent transition history

        Args:
            limit: Maximum number of transitions to return

        Returns:
            List of recent transitions
        """
        with self._lock:
            history_limit = min(limit, len(self._transition_history))
            if history_limit > 0:
                return self._transition_history[-history_limit:]
            else:
                return []</content>
<parameter name="filePath">/home/flash/NRP_ROS/Backend/servo_manager/wp_mark/state_machine.py