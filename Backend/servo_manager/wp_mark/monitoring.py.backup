"""
WP_MARK Metrics and Monitoring Module
Provides comprehensive monitoring, metrics collection, and health tracking
"""

import time
import threading
import psutil
import logging
from typing import Dict, Any, List, Optional, Callable
from collections import defaultdict, deque
from dataclasses import dataclass, field
import json
import os


@dataclass
class MetricPoint:
    """Individual metric data point"""
    timestamp: float
    value: Any
    tags: Dict[str, str] = field(default_factory=dict)


@dataclass
class HealthStatus:
    """System health status"""
    component: str
    status: str  # 'healthy', 'degraded', 'unhealthy'
    message: str
    timestamp: float
    metrics: Dict[str, Any] = field(default_factory=dict)


class MetricsCollector:
    """Collects and aggregates metrics data"""

    def __init__(self, max_points: int = 1000):
        """
        Initialize metrics collector

        Args:
            max_points: Maximum number of data points to keep per metric
        """
        self.max_points = max_points
        self._metrics: Dict[str, deque] = defaultdict(lambda: deque(maxlen=max_points))
        self._counters: Dict[str, int] = defaultdict(int)
        self._gauges: Dict[str, Any] = {}
        self._histograms: Dict[str, List[float]] = defaultdict(list)
        self._lock = threading.RLock()

    def record_counter(self, name: str, value: int = 1, tags: Optional[Dict[str, str]] = None):
        """
        Record a counter metric

        Args:
            name: Metric name
            value: Value to add
            tags: Optional tags
        """
        with self._lock:
            self._counters[name] += value
            point = MetricPoint(
                timestamp=time.time(),
                value=self._counters[name],
                tags=tags or {}
            )
            self._metrics[f"counter.{name}"].append(point)

    def set_gauge(self, name: str, value: Any, tags: Optional[Dict[str, str]] = None):
        """
        Set a gauge metric

        Args:
            name: Metric name
            value: Current value
            tags: Optional tags
        """
        with self._lock:
            self._gauges[name] = value
            point = MetricPoint(
                timestamp=time.time(),
                value=value,
                tags=tags or {}
            )
            self._metrics[f"gauge.{name}"].append(point)

    def record_histogram(self, name: str, value: float, tags: Optional[Dict[str, str]] = None):
        """
        Record a histogram value

        Args:
            name: Metric name
            value: Value to record
            tags: Optional tags
        """
        with self._lock:
            self._histograms[name].append(value)
            point = MetricPoint(
                timestamp=time.time(),
                value=value,
                tags=tags or {}
            )
            self._metrics[f"histogram.{name}"].append(point)

    def record_timer(self, name: str, duration: float, tags: Optional[Dict[str, str]] = None):
        """
        Record a timer/duration metric

        Args:
            name: Metric name
            duration: Duration in seconds
            tags: Optional tags
        """
        with self._lock:
            point = MetricPoint(
                timestamp=time.time(),
                value=duration,
                tags=tags or {}
            )
            self._metrics[f"timer.{name}"].append(point)

    def get_metric_summary(self, name: str, metric_type: str = "counter") -> Dict[str, Any]:
        """
        Get summary statistics for a metric

        Args:
            name: Metric name
            metric_type: Type of metric ('counter', 'gauge', 'histogram', 'timer')

        Returns:
            Summary statistics
        """
        with self._lock:
            key = f"{metric_type}.{name}"
            points = list(self._metrics[key])

            if not points:
                return {'count': 0, 'latest': None}

            values = [p.value for p in points if isinstance(p.value, (int, float))]

            if not values:
                return {'count': len(points), 'latest': points[-1].value if points else None}

            return {
                'count': len(points),
                'latest': points[-1].value,
                'min': min(values),
                'max': max(values),
                'avg': sum(values) / len(values),
                'sum': sum(values)
            }

    def get_all_metrics(self) -> Dict[str, Any]:
        """
        Get all current metrics

        Returns:
            Dictionary of all metrics
        """
        with self._lock:
            result = {
                'counters': dict(self._counters),
                'gauges': dict(self._gauges),
                'histograms': {name: self.get_metric_summary(name, 'histogram')
                             for name in self._histograms.keys()},
                'timers': {}
            }

            # Add timer summaries
            timer_keys = [k for k in self._metrics.keys() if k.startswith('timer.')]
            for key in timer_keys:
                name = key.replace('timer.', '')
                result['timers'][name] = self.get_metric_summary(name, 'timer')

            return result

    def clear_metrics(self, pattern: Optional[str] = None):
        """
        Clear metrics (optionally matching a pattern)

        Args:
            pattern: Pattern to match (None for all)
        """
        with self._lock:
            if pattern:
                keys_to_remove = [k for k in self._metrics.keys() if pattern in k]
                for key in keys_to_remove:
                    self._metrics[key].clear()
                counters_to_remove = [k for k in self._counters.keys() if pattern in k]
                for key in counters_to_remove:
                    del self._counters[key]
                gauges_to_remove = [k for k in self._gauges.keys() if pattern in k]
                for key in gauges_to_remove:
                    del self._gauges[key]
            else:
                self._metrics.clear()
                self._counters.clear()
                self._gauges.clear()
                self._histograms.clear()


class HealthMonitor:
    """Monitors system health and component status"""

    def __init__(self, metrics_collector: Optional[MetricsCollector] = None):
        """
        Initialize health monitor

        Args:
            metrics_collector: Optional metrics collector
        """
        self.metrics = metrics_collector or MetricsCollector()
        self._health_checks: Dict[str, Callable[[], HealthStatus]] = {}
        self._alert_callbacks: List[Callable[[HealthStatus], None]] = []
        self._lock = threading.RLock()

        # Register default health checks
        self.register_health_check('system', self._check_system_health)
        self.register_health_check('memory', self._check_memory_health)
        self.register_health_check('cpu', self._check_cpu_health)

    def register_health_check(self, name: str, check_func: Callable[[], HealthStatus]):
        """
        Register a health check function

        Args:
            name: Health check name
            check_func: Function that returns HealthStatus
        """
        with self._lock:
            self._health_checks[name] = check_func

    def add_alert_callback(self, callback: Callable[[HealthStatus], None]):
        """
        Add callback for health alerts

        Args:
            callback: Function to call on health status changes
        """
        with self._lock:
            self._alert_callbacks.append(callback)

    def perform_health_checks(self) -> Dict[str, HealthStatus]:
        """
        Perform all health checks

        Returns:
            Dictionary of health statuses
        """
        results = {}
        with self._lock:
            for name, check_func in self._health_checks.items():
                try:
                    status = check_func()
                    results[name] = status

                    # Record metrics
                    self.metrics.set_gauge(f"health.{name}.status",
                                         1 if status.status == 'healthy' else 0,
                                         {'component': name})

                    # Trigger alerts for unhealthy components
                    if status.status != 'healthy':
                        self._trigger_alerts(status)

                except Exception as e:
                    error_status = HealthStatus(
                        component=name,
                        status='unhealthy',
                        message=f"Health check failed: {str(e)}",
                        timestamp=time.time()
                    )
                    results[name] = error_status
                    self._trigger_alerts(error_status)

        return results

    def get_overall_health(self) -> str:
        """
        Get overall system health status

        Returns:
            Overall health status
        """
        statuses = self.perform_health_checks()
        if any(s.status == 'unhealthy' for s in statuses.values()):
            return 'unhealthy'
        elif any(s.status == 'degraded' for s in statuses.values()):
            return 'degraded'
        else:
            return 'healthy'

    def _trigger_alerts(self, status: HealthStatus):
        """Trigger alert callbacks"""
        for callback in self._alert_callbacks:
            try:
                callback(status)
            except Exception as e:
                logging.error(f"Alert callback error: {str(e)}")

    def _check_system_health(self) -> HealthStatus:
        """Check basic system health"""
        try:
            # Check if we can access basic system info
            uptime = time.time() - psutil.boot_time()
            load_avg = psutil.getloadavg() if hasattr(psutil, 'getloadavg') else (0, 0, 0)

            status = 'healthy'
            message = 'System is healthy'

            # Check load average (simple threshold)
            if load_avg[0] > 4.0:
                status = 'degraded'
                message = f'High system load: {load_avg[0]}'

            return HealthStatus(
                component='system',
                status=status,
                message=message,
                timestamp=time.time(),
                metrics={
                    'uptime_seconds': uptime,
                    'load_average': load_avg[0]
                }
            )
        except Exception as e:
            return HealthStatus(
                component='system',
                status='unhealthy',
                message=f'System health check failed: {str(e)}',
                timestamp=time.time()
            )

    def _check_memory_health(self) -> HealthStatus:
        """Check memory usage health"""
        try:
            memory = psutil.virtual_memory()
            memory_percent = memory.percent

            status = 'healthy'
            message = f'Memory usage: {memory_percent:.1f}%'

            if memory_percent > 90:
                status = 'unhealthy'
                message = f'Critical memory usage: {memory_percent:.1f}%'
            elif memory_percent > 75:
                status = 'degraded'
                message = f'High memory usage: {memory_percent:.1f}%'

            return HealthStatus(
                component='memory',
                status=status,
                message=message,
                timestamp=time.time(),
                metrics={
                    'used_percent': memory_percent,
                    'available_mb': memory.available / 1024 / 1024
                }
            )
        except Exception as e:
            return HealthStatus(
                component='memory',
                status='unhealthy',
                message=f'Memory health check failed: {str(e)}',
                timestamp=time.time()
            )

    def _check_cpu_health(self) -> HealthStatus:
        """Check CPU usage health"""
        try:
            cpu_percent = psutil.cpu_percent(interval=1)

            status = 'healthy'
            message = f'CPU usage: {cpu_percent:.1f}%'

            if cpu_percent > 95:
                status = 'unhealthy'
                message = f'Critical CPU usage: {cpu_percent:.1f}%'
            elif cpu_percent > 80:
                status = 'degraded'
                message = f'High CPU usage: {cpu_percent:.1f}%'

            return HealthStatus(
                component='cpu',
                status=status,
                message=message,
                timestamp=time.time(),
                metrics={
                    'used_percent': cpu_percent,
                    'cpu_count': psutil.cpu_count()
                }
            )
        except Exception as e:
            return HealthStatus(
                component='cpu',
                status='unhealthy',
                message=f'CPU health check failed: {str(e)}',
                timestamp=time.time()
            )


class PerformanceMonitor:
    """Monitors performance metrics for WP_MARK operations"""

    def __init__(self, metrics_collector: Optional[MetricsCollector] = None,
                 health_monitor: Optional[HealthMonitor] = None):
        """
        Initialize performance monitor

        Args:
            metrics_collector: Optional metrics collector
            health_monitor: Optional health monitor
        """
        self.metrics = metrics_collector or MetricsCollector()
        self.health = health_monitor or HealthMonitor(self.metrics)
        self._operation_timers: Dict[str, float] = {}
        self._lock = threading.RLock()

    def start_operation(self, operation_name: str):
        """
        Start timing an operation

        Args:
            operation_name: Name of the operation
        """
        with self._lock:
            self._operation_timers[operation_name] = time.time()

    def end_operation(self, operation_name: str, success: bool = True,
                     tags: Optional[Dict[str, str]] = None):
        """
        End timing an operation

        Args:
            operation_name: Name of the operation
            success: Whether operation was successful
            tags: Optional tags
        """
        with self._lock:
            if operation_name in self._operation_timers:
                duration = time.time() - self._operation_timers[operation_name]
                del self._operation_timers[operation_name]

                # Record metrics
                self.metrics.record_timer(f"operation.{operation_name}", duration, tags)
                self.metrics.record_counter(f"operation.{operation_name}.{'success' if success else 'failure'}")

                # Record success/failure rate
                status_tag = {'status': 'success' if success else 'failure'}
                if tags:
                    status_tag.update(tags)
                self.metrics.record_counter(f"operation.{operation_name}.count", tags=status_tag)

    def record_mission_event(self, event_type: str, details: Optional[Dict[str, Any]] = None):
        """
        Record a mission event

        Args:
            event_type: Type of event
            details: Optional event details
        """
        self.metrics.record_counter(f"mission.event.{event_type}")
        if details:
            for key, value in details.items():
                if isinstance(value, (int, float)):
                    self.metrics.record_histogram(f"mission.event.{event_type}.{key}", value)

    def get_performance_report(self) -> Dict[str, Any]:
        """
        Generate performance report

        Returns:
            Performance report dictionary
        """
        return {
            'metrics': self.metrics.get_all_metrics(),
            'health': self.health.perform_health_checks(),
            'overall_health': self.health.get_overall_health(),
            'timestamp': time.time()
        }


# Global instances
_metrics_collector = MetricsCollector()
_health_monitor = HealthMonitor(_metrics_collector)
_performance_monitor = PerformanceMonitor(_metrics_collector, _health_monitor)

# Export global instances
metrics_collector = _metrics_collector
health_monitor = _health_monitor
performance_monitor = _performance_monitor
<parameter name="filePath">/home/flash/NRP_ROS/Backend/servo_manager/wp_mark/monitoring.py